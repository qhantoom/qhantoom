use crate::util::symbol::Symbol;

pub static NUMBER_BASE_BIN: u32 = NumberBase::Bin as u32;
pub static NUMBER_BASE_OCT: u32 = NumberBase::Oct as u32;
pub static NUMBER_BASE_DEC: u32 = NumberBase::Dec as u32;
pub static NUMBER_BASE_HEX: u32 = NumberBase::Hex as u32;

pub enum NumberBase {
  Bin = 2,
  Oct = 8,
  Dec = 10,
  Hex = 16,
}

#[derive(Clone, Debug, PartialEq)]
pub enum TokenKind {
  EOF,
  Newline,
  // comments,
  CommentLine,
  CommentBlock,
  CommentDocLine,
  CommentDocBlock,
  // primitives
  Int(i64),
  Float(f64),
  CharAscii(char),
  StrBuffer(Symbol),
  Identifier(Symbol),
  // groups
  OpenParen,
  CloseParen,
  OpenBrace,
  CloseBrace,
  OpenBracket,
  CloseBracket,
  // operators
  Add,
  Sub,
  Mul,
  Div,
  Rem,
  Num, // #
  Caret,
  Not,
  Eq,
  Ne,
  Lt,
  Le,
  Gt,
  Ge,
  Shl,
  Shr,
  And,
  Or,
  AndAnd,
  OrOr,
  Assign,
  AddAssign,
  SubAssign,
  MulAssign,
  DivAssign,
  RemAssign,
  BitAndAssign,
  BitXorAssign,
  BitOrAssign,
  ColonAssign,
  CaretAssign,
  DotAssign,
  // punctuators
  At,
  Question,
  Underscore,
  Colon,
  ColonColon,
  Semi,
  Comma,
  Dot,
  DotDot,
  DotEq,
  FatArrow,
  ThinArrow,
  Dollar,
  // keywords
  Action,
  As,
  Async,
  Await,
  Bench,
  Bind,
  Break,
  Chan,
  Continue,
  Else,
  Enum,
  Exp,
  Ext,
  False,
  Fun,
  For,
  If,
  Imu,
  Load,
  Loop,
  Match,
  MeUpper,
  MeLower,
  Mock,
  Mod,
  Mut,
  Pub,
  Ref,
  Return,
  Set,
  Spawn,
  Struct,
  Test,
  True,
  Type,
  Unit,
  Val,
  Void,
  Wasm,
  While,
  // types
  Bool,
  U8,
  U16,
  U32,
  U64,
  UInt,
  S8,
  S16,
  S32,
  S64,
  SInt,
  F32,
  F64,
  Char,
  Str,
}

impl TokenKind {
  #[inline]
  pub fn is(&self, k: &TokenKind) -> bool {
    self == k
  }

  #[inline]
  pub fn is_eof(&self) -> bool {
    *self == Self::EOF
  }

  #[inline]
  pub fn keywords(ident: &str) -> Option<Self> {
    match ident {
      // keywords
      "action" => Some(Self::Action),
      "as" => Some(Self::As),
      "async" => Some(Self::Async),
      "await" => Some(Self::Await),
      "bench" => Some(Self::Bench),
      "bind" => Some(Self::Bind),
      "break" => Some(Self::Break),
      "chan" => Some(Self::Chan),
      "continue" => Some(Self::Continue),
      "else" => Some(Self::Else),
      "enum" => Some(Self::Enum),
      "exp" => Some(Self::Exp),
      "ext" => Some(Self::Ext),
      "false" => Some(Self::False),
      "fun" => Some(Self::Fun),
      "for" => Some(Self::For),
      "if" => Some(Self::If),
      "imu" => Some(Self::Imu),
      "load" => Some(Self::Load),
      "loop" => Some(Self::Loop),
      "match" => Some(Self::Match),
      "Me" => Some(Self::MeUpper),
      "me" => Some(Self::MeLower),
      "mock" => Some(Self::Mock),
      "mod" => Some(Self::Mod),
      "mut" => Some(Self::Mut),
      "pub" => Some(Self::Pub),
      "ref" => Some(Self::Ref),
      "return" => Some(Self::Return),
      "set" => Some(Self::Set),
      "spawn" => Some(Self::Spawn),
      "struct" => Some(Self::Struct),
      "test" => Some(Self::Test),
      "true" => Some(Self::True),
      "type" => Some(Self::Type),
      "_" => Some(Self::Underscore),
      "unit" => Some(Self::Unit),
      "val" => Some(Self::Val),
      "void" => Some(Self::Void),
      "wasm" => Some(Self::Wasm),
      "while" => Some(Self::While),
      // types
      "bool" => Some(Self::Bool),
      "char" => Some(Self::Char),
      "str" => Some(Self::Str),
      "f32" => Some(Self::F32),
      "f64" => Some(Self::F64),
      "s8" => Some(Self::S8),
      "s16" => Some(Self::S16),
      "s32" => Some(Self::S32),
      "s64" => Some(Self::S64),
      "sint" => Some(Self::SInt),
      "u8" => Some(Self::U8),
      "u16" => Some(Self::U16),
      "u32" => Some(Self::U32),
      "u64" => Some(Self::U64),
      "uint" => Some(Self::UInt),
      _ => None,
    }
  }
}
