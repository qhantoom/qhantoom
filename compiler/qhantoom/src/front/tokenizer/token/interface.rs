use std::ops::Deref;

use crate::util::symbol::Symbol;

use self::TokenKind::*;

#[derive(Clone, Debug, PartialEq)]
pub enum NumberSize {
  Bin,
  Oct,
  Dec,
  Hex,
}

impl Deref for NumberSize {
  type Target = u32;

  #[inline]
  fn deref(&self) -> &Self::Target {
    match *self {
      Self::Bin => &2,
      Self::Oct => &8,
      Self::Dec => &10,
      Self::Hex => &16,
    }
  }
}

#[derive(Clone, Debug, PartialEq)]
pub enum TokenKind {
  EOF,
  Unknown,
  NewLine,
  Semicolon,
  Comma,
  Ne,
  Dot,
  Add,
  Sub,
  Div,
  Mul,
  Mod,
  Bang,
  Colon,
  And,
  Lt,
  Gt,
  Eq,
  Pipe,
  AddEq,
  SubEq,
  DivEq,
  MulEq,
  ModEq,
  BangEq,
  DotEq,
  ColonEq,
  AndEq,
  LtEq,
  GtEq,
  PipeEq,
  EqEq,
  AddAdd,
  SubSub,
  DivDiv,
  MulMul,
  ModMod,
  BangBang,
  DotDot,
  ColonColon,
  AndAnd,
  LtLt,
  GtGt,
  PipePipe,
  Le,
  Ge,
  QuestionMark,
  BackSlash,
  Arrow,
  ArrowFat,
  Underscore,
  OpenParen,
  CloseParen,
  OpenBrace,
  CloseBrace,
  OpenBracket,
  CloseBracket,
  As,
  Async,
  Await,
  Bench,
  Bind,
  Break,
  Capsule,
  Chan,
  Continue,
  Else,
  Enum,
  Exp,
  Ext,
  False,
  FunLower,
  For,
  If,
  Imu,
  Load,
  Loop,
  Match,
  MeUpper,
  MeLower,
  Mock,
  Module,
  Mut,
  Pack,
  Pub,
  Ref,
  Ret,
  Spawn,
  Struct,
  True,
  Test,
  Unit,
  Val,
  Void,
  Wasm,
  While,
  All,
  Any,
  Concat,
  Drop,
  Filter,
  Find,
  Fold,
  Head,
  Insert,
  Last,
  Min,
  Map,
  Max,
  Repeat,
  Reverse,
  Sort,
  Sum,
  Tail,
  Take,
  Unzip,
  Zip,
  U8,
  U16,
  U32,
  U64,
  Uint,
  S8,
  S16,
  S32,
  S64,
  Sint,
  F32,
  F64,
  Bytes,
  FunUpper,
  Bool,
  Char,
  Str,
  IntNumber(i32),
  FloatNumber(f32),
  StrBuffer(String),
  CharAscii(char),
  CommentLine(String),
  Ident(Symbol),
  Type(Symbol),
}

impl TokenKind {
  #[inline]
  pub fn keyword(s: &str) -> Option<Self> {
    match s {
      "as" => Some(As),
      "async" => Some(Async),
      "await" => Some(Await),
      "bench" => Some(Bench),
      "bind" => Some(Bind),
      "break" => Some(Break),
      "capsule" => Some(Capsule),
      "chan" => Some(Chan),
      "continue" => Some(Continue),
      "else" => Some(Else),
      "enum" => Some(Enum),
      "exp" => Some(Exp),
      "ext" => Some(Ext),
      "false" => Some(False),
      "fun" => Some(FunLower),
      "for" => Some(For),
      "if" => Some(If),
      "imu" => Some(Imu),
      "load" => Some(Load),
      "loop" => Some(Loop),
      "match" => Some(Match),
      "Me" => Some(MeUpper),
      "me" => Some(MeLower),
      "mock" => Some(Mock),
      "mod" => Some(Module),
      "mut" => Some(Mut),
      "pack" => Some(Pack),
      "pub" => Some(Pub),
      "ref" => Some(Ref),
      "ret" => Some(Ret),
      "spawn" => Some(Spawn),
      "struct" => Some(Struct),
      "test" => Some(Test),
      "true" => Some(True),
      "unit" => Some(Unit),
      "val" => Some(Val),
      "void" => Some(Void),
      "while" => Some(While),
      "wasm" => Some(Wasm),
      "_" => Some(Underscore),
      "all" => Some(All),
      "any" => Some(Any),
      "concat" => Some(Concat),
      "drop" => Some(Drop),
      "filter" => Some(Filter),
      "find" => Some(Find),
      "fold" => Some(Fold),
      "head" => Some(Head),
      "insert" => Some(Insert),
      "last" => Some(Last),
      "min" => Some(Min),
      "map" => Some(Map),
      "max" => Some(Max),
      "repeat" => Some(Repeat),
      "reverse" => Some(Reverse),
      "sort" => Some(Sort),
      "sum" => Some(Sum),
      "tail" => Some(Tail),
      "take" => Some(Take),
      "unzip" => Some(Unzip),
      "zip" => Some(Zip),
      "u8" => Some(U8),
      "u16" => Some(U16),
      "u32" => Some(U32),
      "u64" => Some(U64),
      "uint" => Some(Uint),
      "s8" => Some(S8),
      "s16" => Some(S16),
      "s32" => Some(S32),
      "s64" => Some(S64),
      "sint" => Some(Sint),
      "f32" => Some(F32),
      "f64" => Some(F64),
      "bytes" => Some(Bytes),
      "Fun" => Some(FunUpper),
      "bool" => Some(Bool),
      "char" => Some(Char),
      "str" => Some(Str),
      _ => None,
    }
  }

  #[inline]
  pub fn is(&self, k: TokenKind) -> bool {
    *self == k
  }

  #[inline]
  pub fn is_eof(&self) -> bool {
    *self == Self::EOF
  }

  #[inline]
  pub fn is_reserved_keyword(s: &str) -> bool {
    match s {
      "char" | "str" | "void" => true,
      _ => false,
    }
  }
}
